//******************************************************************************
//                             Application.java
// OpenSILEX
// Copyright Â© INRA 2019
// Creation date: 01 jan. 2019
// Contact: vincent.migot@inra.fr, anne.tireau@inra.fr, pascal.neveu@inra.fr
//******************************************************************************
package org.opensilex.core;

import org.opensilex.core.config.ApplicationCoreConfig;
import org.cfg4j.source.context.filesprovider.ConfigFilesProvider;
import java.util.ArrayList;
import org.cfg4j.provider.ConfigurationProvider;
import org.cfg4j.provider.ConfigurationProviderBuilder;
import org.cfg4j.source.ConfigurationSource;
import org.cfg4j.source.context.environment.ImmutableEnvironment;
import org.cfg4j.source.files.FilesConfigurationSource;
import io.swagger.jaxrs.config.BeanConfig;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.JarURLConnection;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Map;
import java.util.Properties;
import java.util.ServiceLoader;
import java.util.concurrent.TimeUnit;
import javax.inject.Singleton;
import javax.ws.rs.ApplicationPath;
import org.cfg4j.source.context.environment.Environment;
import org.cfg4j.source.reload.strategy.PeriodicalReloadStrategy;
import org.glassfish.hk2.utilities.binding.AbstractBinder;
import org.glassfish.jersey.server.ResourceConfig;
import org.opensilex.core.config.MongoDBConfig;
import org.opensilex.core.config.RDF4JConfig;
import org.opensilex.core.mongodb.MongoDBService;
import org.opensilex.core.mongodb.MongoDBServiceImpl;
import org.opensilex.core.sparql.RDF4JService;
import org.opensilex.core.sparql.SPARQLService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class is the main entry point of OpenSILEX application It extends Jersey
 * ResourceConfig with main API entry point /rest
 *
 * @see https://jersey.github.io/
 *
 * It handle YAML configuration loading with CFG4j in its constructor
 * http://www.cfg4j.org/
 *
 * It also manage module initialization through Java Service Provider Interface
 * @see https://docs.oracle.com/javase/tutorial/ext/basics/spi.html
 */
@ApplicationPath("/rest")
@Singleton
public class Application extends ResourceConfig {

    final private static Logger LOGGER = LoggerFactory.getLogger(Application.class);

    /**
     * Production profile identifier
     */
    final private static String PROD_PROFILE_ID = "prod";

    /**
     * Development profile identifier
     */
    final private static String DEV_PROFILE_ID = "dev";

    /**
     * Main application properties file generated by maven plugins It contains
     * all properties defined in pom.xml during build
     */
    final private static String APP_PROPERTIES = "app.properties";

    /**
     * Properties wich will be filled with those generated during maven build
     */
    final private Properties properties = new Properties();

    /**
     * Service loader for laoding automatically every OpenSilexModule
     * implementations
     */
    final private ServiceLoader<OpenSilexModule> serviceLoader;

    /**
     * Configuration provider wich contains all merged configuration from
     * modules and instance
     */
    private ConfigurationProvider configProvider;

    /**
     * Core configuration
     */
    private ApplicationCoreConfig coreConfig;

    /**
     * RDF4J configuration
     */
    private RDF4JConfig rdf4jConfig;

    /**
     * MongoDB configuration
     */
    private MongoDBConfig mongoDBConfig;

    /**
     * Constructor for opensilex Application which It'ss
     */
    public Application() {

        // Initialise service loader to find all modules and define this application to them
        serviceLoader = ServiceLoader.load(OpenSilexModule.class);
        for (OpenSilexModule module : serviceLoader) {
            module.setApplication(this);
        }

        // Read build properties generated by maven plugin
        final InputStream stream = getClass().getClassLoader().getResourceAsStream(APP_PROPERTIES);
        try {
            properties.load(stream);
            stream.close();
        } catch (IOException ex) {
            LOGGER.error("Error while loading application properties", ex);
        }

        // Initialize configuration provider for every module and application
        initConfigProvider();

        // Load core configuration
        coreConfig = loadConfig("opensilex-core", ApplicationCoreConfig.class);

        // Load RDF4J configuration
        rdf4jConfig = loadConfig("opensilex-core-rdf4j", RDF4JConfig.class);

        // Load MongoDB configuration
        mongoDBConfig = loadConfig("opensilex-core-mongo", MongoDBConfig.class);

        // Register all module packages needed for service initialization
        registerPackagesToScanFromModules();

        // Initialize swagger API
        initSwagger();

        // Allow all modules to do custom initialization
        initModules();

        // Create and register binding for service injection
        Application self = this;
        register(new AbstractBinder() {
            @Override
            protected void configure() {
                // Initialize SPARQLService
                bind(new RDF4JService(self.getRDF4JConfig())).to(SPARQLService.class);

                // Initialize MongoDB Service
                bind(new MongoDBServiceImpl(self.getMongoDBConfig())).to(MongoDBService.class);

                // Make every module injectable
                for (OpenSilexModule module : self.getModuleIterator()) {
                    bind(module).to((Class<? super OpenSilexModule>) module.getClass());
                }
            }
        });
    }

    /**
     * Parse YAML configuration and initialize "config" class member
     */
    private void initConfigProvider() {
        ArrayList<Path> paths = new ArrayList<>();

        String profileId = getProfileId();
        LOGGER.info("Load configuration for profile: " + profileId);

        // Copy prod and if different profile configuration to current classpath for every module in a specific folder
        // Add path to those files to loaded configuration files
        String baseDestinationPath = getClass().getClassLoader().getResource(".").getFile();
        for (OpenSilexModule module : serviceLoader) {
            copyAndRegisterModuleConfig(module, baseDestinationPath, paths);
        }

        registerMainConfig(baseDestinationPath, paths);

        LOGGER.debug("Config file order:");
        for (Path path : paths) {
            LOGGER.debug("./" + path.getParent().getFileName().toString() + "/" + path.getFileName().toString());
        }

        // Specify which files to load. Configuration from all files will be merged.
        ConfigFilesProvider configFilesProvider = () -> paths;
        ConfigurationSource source = new FilesConfigurationSource(configFilesProvider);
        Environment environment = new ImmutableEnvironment(baseDestinationPath);
        configProvider = new ConfigurationProviderBuilder()
                .withConfigurationSource(source)
                .withEnvironment(environment)
                .withReloadStrategy(new PeriodicalReloadStrategy(1, TimeUnit.DAYS))
                .build();

        LOGGER.debug("Loaded configuration:");
        for (Map.Entry<Object, Object> cfgEntry : configProvider.allConfigurationAsProperties().entrySet()) {
            LOGGER.debug(cfgEntry.getKey() + " -> " + cfgEntry.getValue());
        }
    }

    /**
     * Search for module configuration files depending on which profile is
     * active Create a folder for the module in webapp base path to store
     * configuration by module Copy all configuration files found to this folder
     * and register the corresponding path In all case prod module configuration
     * file is registred first is found Case other profile: If profile is dev or
     * an extension of dev, register module dev configuration file if found
     *
     * @param module module to analyse for configuration files
     * @param baseDestinationPath base path where configuration files for
     * modules will be copied
     * @param paths List of configuration files to load in overriding order
     */
    private void copyAndRegisterModuleConfig(OpenSilexModule module, String baseDestinationPath, ArrayList<Path> paths) {
        // Get module class name as identifier
        String moduleClassName = module.getClass().getName();
        LOGGER.info("Initialize configuration files for: " + moduleClassName);

        // Get module resource base path (jar or directory)
        String moduleSourcePath = module.getClass().getProtectionDomain().getCodeSource().getLocation().toString();
        LOGGER.info("Module configuration source: " + moduleSourcePath);

        // Create module folder in webapp base path
        String moduleConfigDestinationPath = baseDestinationPath + moduleClassName;
        LOGGER.info("Create local configuration folder: " + moduleClassName);
        new File(moduleConfigDestinationPath).mkdirs();

        // Copy module production config file and register it if exist 
        Path path = copyModuleProfileConfig(moduleSourcePath, PROD_PROFILE_ID, moduleConfigDestinationPath);
        if (path != null) {
            paths.add(path);
            LOGGER.info(moduleClassName + " - Config file copied and registred for profile: " + PROD_PROFILE_ID);
        }

        if (!getProfileId().equals(PROD_PROFILE_ID)) {
            // If current profile is dev or an extension of dev, register dev module configuration file
            if (isDev()) {
                // If current profile is dev, copy module dev config file and register it if exist 
                path = copyModuleProfileConfig(moduleSourcePath, DEV_PROFILE_ID, moduleConfigDestinationPath);
                if (path != null) {
                    paths.add(path);
                    LOGGER.info(moduleClassName + " - Config file copied and registred for profile: " + DEV_PROFILE_ID);
                }
            }
        }
    }

    /**
     * Register main configuration files path depending on which profile is
     * active In all case prod main configuration file is registred first is
     * found Case dev profile: main dev configuration file is registred if found
     * Case other profile: If custom profile is an extension of dev, register
     * main dev configuration file if found Then register custom profile
     * configuration file if found
     *
     * @param basePath base path where configuration files are stored
     * @param paths List of configuration files to load in overriding order
     */
    private void registerMainConfig(String basePath, ArrayList<Path> paths) {
        // Register main production configuration file by default
        File prodConfigFile = new File(basePath + "config-overrides/" + PROD_PROFILE_ID + "/opensilex.yaml");
        if (prodConfigFile.exists()) {
            paths.add(Paths.get(prodConfigFile.getPath()));
            LOGGER.info("Main config file registred for profile: " + PROD_PROFILE_ID);
        }

        if (!getProfileId().equals(PROD_PROFILE_ID)) {
            // If current profile is dev or an extension of dev, register dev main configuration file
            if (isDev()) {
                File extensionConfigFile = new File(basePath + "config-overrides/" + DEV_PROFILE_ID + "/opensilex.yaml");
                if (extensionConfigFile.exists()) {
                    paths.add(Paths.get(extensionConfigFile.getPath()));
                    LOGGER.info("Main config file registred for profile: " + DEV_PROFILE_ID);
                }
            }

            // If current profile is neither dev or prod register custom profile main configuration            
            if (!getProfileId().equals(DEV_PROFILE_ID)) {
                File profileConfigFile = new File(basePath + "config-overrides/" + getProfileId() + "/opensilex.yaml");
                if (profileConfigFile.exists()) {
                    paths.add(Paths.get(profileConfigFile.getPath()));
                    LOGGER.info("Main config file found for profile: " + getProfileId());
                }
            }
        }
    }

    /**
     * Try to copy module config file for the given profile to the module config
     * directory This file could be located either in a jar or in the webapp
     * classpath The config file will be copied with the pattern
     * opensilex-{profileId}.yaml This method return the copied file path or
     * null if it doesn't exist
     *
     * @param moduleSourcePath base source of the module (jar file or directory)
     * @param profileId profile identifier
     * @param moduleDestinationPath module config directory
     * @return Path | null
     */
    private Path copyModuleProfileConfig(String moduleSourcePath, String profileId, String moduleDestinationPath) {
        File dest = new File(moduleDestinationPath + "/opensilex-" + profileId + ".yaml");

        try {
            if (moduleSourcePath.endsWith(".jar")) {
                // If module source is a jar file open a stream to it
                String jarBaseUrl = "jar:" + moduleSourcePath + "!";
                URL url = new URL(jarBaseUrl + "/config/" + profileId + "/opensilex.yaml");
                JarURLConnection connection = (JarURLConnection) url.openConnection();
                InputStream inStream = connection.getInputStream();

                // Read all input stream
                byte[] buffer = new byte[inStream.available()];
                inStream.read(buffer);

                // Write it all to output stream destination
                OutputStream outStream = new FileOutputStream(dest);
                outStream.write(buffer);
                outStream.flush();

                // Close streams
                inStream.close();
                outStream.close();
            } else {
                // If module source is a directory 
                URL configUrl = new URL(moduleSourcePath + "config/" + profileId + "/opensilex.yaml");

                // Copy it only if it exists
                if (new File(configUrl.getPath()).exists()) {
                    Files.copy(Paths.get(configUrl.getPath()), dest.toPath());
                }
            }
        } catch (FileNotFoundException ex) {
            LOGGER.info("Config file not found: " + ex.getMessage());
        } catch (IOException ex) {
            LOGGER.error("Error while copying " + profileId + " configuration file: " + moduleSourcePath, ex);
        }

        if (dest.exists()) {
            return dest.toPath();
        } else {
            return null;
        }
    }

    /**
     * Initialize packages list to scan for services and request filters (A.K.A.
     * components) from all modules
     *
     * @see
     * https://jersey.github.io/apidocs/2.28/jersey/org/glassfish/jersey/server/ResourceConfig.html#packages-boolean-java.lang.String...-
     */
    private void registerPackagesToScanFromModules() {
        ArrayList<String> packageList = new ArrayList<>();

        // Get packages list from every modules
        for (OpenSilexModule module : serviceLoader) {
            packageList.addAll(module.getPackagesToScan());
            packageList.addAll(module.getServicesPackagesToScan());
        }

        // Add package list for components scan
        packages(String.join(";", packageList));
    }

    /**
     * Initialize swagger UI registering every packages to scan for services
     * defined in modules
     */
    private void initSwagger() {
        // Load all packages to scan from modules
        ArrayList<String> packageList = new ArrayList<>();

        for (OpenSilexModule module : serviceLoader) {
            packageList.addAll(module.getServicesPackagesToScan());
        }

        // Init swagger UI
        BeanConfig beanConfig = new BeanConfig();
        beanConfig.setVersion(getVersion());
        beanConfig.setSchemes(new String[]{coreConfig.scheme()});
        beanConfig.setHost(coreConfig.host() + ":" + coreConfig.port());
        beanConfig.setBasePath(coreConfig.basePath() + "/rest");
        beanConfig.setResourcePackage(String.join(",", packageList));
        beanConfig.setScan(true);
    }

    /**
     * Call init method of every OpenSILEX modules
     */
    private void initModules() {
        for (OpenSilexModule module : serviceLoader) {
            module.init();
        }
    }

    /**
     * Return application Core configuration
     *
     * @return application Core configuration
     */
    public ApplicationCoreConfig getCoreConfig() {
        return coreConfig;
    }

    /**
     * Return RDF4J Core configuration
     *
     * @return RDF4J Core configuration
     */
    public RDF4JConfig getRDF4JConfig() {
        return rdf4jConfig;
    }

    /**
     * Return MongoDB Core configuration
     *
     * @return MongoDB Core configuration
     */
    public MongoDBConfig getMongoDBConfig() {
        return mongoDBConfig;
    }

    /**
     * Return maven build profile identifier (prod by default) Application
     * define two main profile (dev and prod) but users can defined their own
     * based on them.
     *
     * @return maven build profile identifier
     */
    public String getProfileId() {
        return properties.getProperty("profile.id", PROD_PROFILE_ID);
    }

    /**
     * Return maven build profile extension identifier (prod by default) The
     * only other value which can be return is dev
     *
     * @return prod or dev profile extension identifier
     */
    public String getProfileExtensionId() {
        String profileExtension = properties.getProperty("profile.extension.id", PROD_PROFILE_ID);

        if (!profileExtension.equals(DEV_PROFILE_ID)) {
            profileExtension = PROD_PROFILE_ID;
        }

        return profileExtension;
    }

    /**
     * Determine if maven build profile is prod or an extension of prod
     *
     * @return true if maven profile is prod or an extension of it false
     * otherwise
     */
    public boolean isProd() {
        return getProfileId().equals(PROD_PROFILE_ID)
                || getProfileExtensionId().equals(PROD_PROFILE_ID);
    }

    /**
     * Determine if maven build profile is dev or an extension of dev
     *
     * @return true if maven profile is dev or an extension of it false
     * otherwise
     */
    public boolean isDev() {
        return getProfileId().equals(DEV_PROFILE_ID)
                || getProfileExtensionId().equals(DEV_PROFILE_ID);
    }

    /**
     * Return maven build version (empty string if not defined)
     *
     * @return maven build version
     */
    public String getVersion() {
        return properties.getProperty("revision", "");
    }

    /**
     * Give public access to module iterator
     *
     * @return Iterator on modules
     */
    public Iterable<OpenSilexModule> getModuleIterator() {
        return serviceLoader;
    }

    /**
     * Allow other module to map global loaded YAML config key with an interface
     *
     * @param <T> The config interface
     * @param key The root key in YAML config
     * @param configClass The interface which map to the configuration structure
     *
     * @return An instance of a class which contains all the loaded
     * configuration
     */
    public <T> T loadConfig(String key, Class<T> configClass) {
        T config = configProvider.bind(key, configClass);

        return config;
    }
}
